# Exploiting Buffer overflows

So far we have seen how to find a buffer overflow and how it works. So how can we exploit this vulnerability? Since we already know how the good password program works, we will try to exploit it. The purpose will be to craft a payload that will allow us to run calc.exe.

![](.gitbook/assets/image%20%281%29.png)

![](.gitbook/assets/image%20%2821%29.png)

At this point, EIP points to 44434241 \(ABCD\), while ESP points to OTHER. In order to execute our shellcode, we will have to overwrite the EIP \(ABCD\) with the address of our shellcode.

Basically, we need to fill the first 22 bytes \(local vars + EBP\), with junk data \(NOPâ€™s\), rewrite the EIP and then insert the shell code.

![](.gitbook/assets/image%20%2818%29.png)

Finding the offset

Use pattern create to create the junk bytes

```text
./pattern_create.rb 100
```

Copy the ASCII payload and use it as the input in the good password application.

![](.gitbook/assets/image%20%2859%29.png)

Copy this value \(EIP\)and use it as input for the second script: pattern\_offset.rb:

![](.gitbook/assets/image%20%2860%29.png)

You can also use mona module to do the same ! please read this [3\_Buffer\_Overflow.pdf](file:///D:/e-LearnSecurity/ePTP%20v5/1-%20System%20Security/3_Buffer_Overflow.pdf)

At this point, our shellcode is stored at the memory address pointed by ESP, therefore, returning to our shellcode means jumping to that address. The problem is that the address in the stack changes dynamically, so we cannot use it to build the exploit.

What we can do is find a JMP ESP \(or CALL ESP\) instruction that is in a fixed location of memory. This way when the program returns, instead of ABCD, it will execute a JMP ESP \(or CALL ESP\), and it will automatically jump to the area where our shellcode is stored.

In environments where ASLR is not enabled, we know that kernel32.dll functions are located at fixed addresses in memory; this allows us to perform a JMP ESP or a CALL ESP to the process address space, a line in kernel32.dll. We can safely jump to this line and back from the kernel32 to the address in ESP \(that holds the first line of our shell code\).

There are different tools and techniques that we can use to detect the address of a CALL/JMP ESP. One of them is to simply disassemble the .dll and then search for the instruction. To disassemble a .dll you can load it into Immunity Debugger \(or IDA\) and then search for one of two commands: CALL ESP or JMP ESP.

We can also use mona module

![](.gitbook/assets/image%20%2840%29.png)

![](.gitbook/assets/image%20%2857%29.png)

It is important to remember that we are working on little-endian systems. Therefore, all the addresses found must be used carefully.

**Important!** In order to correctly write this address, we will have to write it in little-endian. Hence, the hexadecimal value in our exploit program will be \x3B\x7D\x26\x77 and not \x77\x26\x7D\x3B.

Now that we have the address of a CALL ESP, we need to create a payload that exploits the buffer overflow vulnerability.

we can create a small script and pass all the values

![](.gitbook/assets/image%20%2873%29.png)

This program calls goodpwd.exe and passes the content of the variable command as an argument. The variable command is composed as follows: Junk bytes + EIP + Shellcode.

Also, notice that at the beginning of the shellcode we added some NOPs \(\x90\). Therefore, once the JMP ESP is executed, the first instruction that will be executed is a NOP. The program will then continue to slide down the NOPs and execute the actual shellcode.

![](.gitbook/assets/image%20%2849%29.png)





